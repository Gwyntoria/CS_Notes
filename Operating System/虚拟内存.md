# 虚拟内存

## 1. 虚拟地址空间分布

在 Linux 系统中，一个可执行文件在运行时会被加载到内存中，并分配一个虚拟地址空间。这个虚拟地址空间分为多个段（sections），每个段都有特定的用途。以下是典型的虚拟地址空间的布局：

### 1.1. Text Segment (代码段)

- **用途**：存放可执行文件的机器指令，也就是程序的代码。
- **属性**：只读且可执行，防止程序意外修改代码。
- **位置**：一般从虚拟地址空间的较低地址开始。

### 1.2. Data Segment (数据段)

- **用途**：存放已初始化的全局变量和静态变量。
- **属性**：可读写，但不可执行。
- **位置**：紧接着代码段之后。

### 1.3. BSS Segment (未初始化数据段)

- **用途**：存放未初始化的全局变量和静态变量。这部分在加载时会被初始化为零。
- **属性**：可读写，但不可执行。
- **位置**：紧接着数据段之后。

### 1.4. Heap Segment (堆)

- **用途**：用于动态内存分配。`malloc`、`calloc`、`realloc`等函数分配的内存来自堆。
- **属性**：可读写。
- **位置**：堆通常位于 BSS 段之后，并向高地址方向增长。

### 1.5. Stack Segment (栈)

- **用途**：存放函数的局部变量、返回地址、参数等。每调用一个函数，栈就会向低地址方向增长，函数返回时栈指针回退。
- **属性**：可读写，通常是最后一个段。
- **位置**：栈位于虚拟地址空间的高地址，并向低地址方向增长。

### 1.6. Memory-mapped Segment (内存映射段)

- **用途**：映射文件、共享内存或其他资源。比如动态链接库（shared libraries）通常通过内存映射加载到这个区域。
- **属性**：读写权限取决于映射对象的属性。
- **位置**：通常位于堆和栈之间的地址空间。

### 1.7. Kernel Space (内核空间)

- **用途**：在用户态程序不可访问的部分虚拟地址空间中，Linux 内核会保留一部分虚拟地址空间用于自身的运行。这个区域对用户态程序不可见和不可访问。
- **位置**：通常位于虚拟地址空间的最顶部。

## 2. 典型的虚拟地址空间布局图

```text
+------------------------+  高地址
|                        |
|     Kernel Space       |
|                        |
+------------------------+
|     Memory-mapped      |
|                        |
+------------------------+
|         Stack          | <- 高地址 (向下增长)
|                        |
+------------------------+
|         Heap           | <- 低地址 (向上增长)
|                        |
+------------------------+
|         BSS            |
+------------------------+
|         Data           |
+------------------------+
|         Text           |
+------------------------+  低地址
```

## 3. 其他补充：

- **共享库的加载**：共享库通常使用内存映射加载到 Memory-mapped 段。
- **堆和栈的动态调整**：堆和栈之间的空隙在进程运行期间可以动态调整。堆向上增长，栈向下增长。

这种虚拟地址空间的布局方式为进程的安全性和稳定性提供了保障，例如通过分段和保护机制来防止进程在错误情况下影响到其他段的数据。
